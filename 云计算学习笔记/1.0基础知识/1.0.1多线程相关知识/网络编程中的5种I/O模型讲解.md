---
title: 网络编程中的5种I/O模型讲解 
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---

五种IO模型包括：阻塞IO、非阻塞IO、信号驱动IO、IO多路转接、异步IO。其中，前四个被称为同步IO。
在内核数据copy到用户空间时都是阻塞的。


[TOC!]

# 阻塞IO 

　　使用recv的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。打个比方，A同学排队买票，他只能排队买上票才可以离开。这一过程就可以看成使用了阻塞       IO模型，因为如果在没买到票之前，他不能离开队伍做别的事情（离开等于白排队，回来又要重新排队）。很显然这种，I/O模型是同步的。

![ 阻塞IO](https://github.com/ltllml42/img/2019/11/1/1572615023845.png)

# 非阻塞IO

　改变flags,让recv不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用recv看看，如此循环。对比阻塞模型，相当于A同学买票过程中，采用了取号买票，再没有到他前，他可以不断的返回购票大厅看下是不是到了自己的号，中间的过程可以做其他事情。他就不用向之前一样一刻不能离开购票大厅。这就是非阻塞IO模型。但是它只有是检查无数据的时候是非阻塞的，在数据到达的时候依然要等待复制数据到用户空间(到自己的号买上票)，因此它还是同步IO。

![非阻塞IO](https://github.com/ltllml42/img/2019/11/1/1572615057823.png)

# 信号驱动IO
![信号驱动IO](https://github.com/ltllml42/img/2019/11/1/1572615148703.png)
# IO多路转接
![IO多路转接](https://github.com/ltllml42/img/2019/11/1/1572615110605.png)


# 异步IO
![异步IO](https://github.com/ltllml42/img/2019/11/1/1572615160966.png)



# 总结

　IO分两阶段：
1.数据准备阶段
2.内核空间复制回用户进程缓冲区阶段

　一般来讲：阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。只有异步IO模型是符合异步IO操作含义的，不管在阶段1还是阶段2都可以干别的事。